#include <stdio.h>
#include <stdbool.h>
#include <wchar.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>

/*
we were having issues with how unicode prints on windows compared to windows.
This program has only been tested for the following terminals: zsh, powershell
*/
// Windows-specific headers
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
#endif
#ifdef __APPLE__
#include<locale.h>
#endif
// Game symbols (wide characters)
const wchar_t block = L'█';
const wchar_t characterUp = L'˅';
const wchar_t characterDown = L'^';
const wchar_t characterLeft = L'>';
const wchar_t characterRight = L'<';
const wchar_t ghost = L'ᗣ';
const wchar_t pellet = L'•';
const wchar_t powerPellet = L'⬤';
const wchar_t es = L' '; // empty space

#define ROWS 21
#define COLS 19

/*
we then made true false arrays for all items. this makes everything very simple to keep up with
needed one for walls pellets powerpellets player and ghost (so 5). made walls const so that way the wall cannot be replaced.

*/
const bool wallExists[ROWS][COLS] = {
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
    {1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1},
    {1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1},
    {1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1},
    {0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0},
    {1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1},
    {0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0},
    {1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1},
    {0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0},
    {1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
    {1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1},
    {1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
    {1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1},
    {1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1},
    {1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1} };
bool pelletsExists[ROWS][COLS] = {
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0},
    {0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0},
    {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
    {0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0},
    {0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0},
    {0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
    {0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
    {0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
    {0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
    {0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
    {0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
    {0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
    {0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0},
    {0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0},
    {0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0},
    {0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0},
    {0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0},
    {0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0},
    {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
bool powerPelletExist[ROWS][COLS] = {
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

bool playerExist[ROWS][COLS] = {
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

bool ghostExist[ROWS][COLS] = {
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

// Initialize console for Unicode (cross-platform)
void init_console() {
    #ifdef _WIN32
        _setmode(_fileno(stdout), _O_U16TEXT); // Windows
    #else
        setlocale(LC_ALL, "en_US.UTF-8"); // Mac/Linux
    #endif
}

int getRandomNumber() {
    return rand() % 100 + 1; // returns a number between 1 and 100
}



void updateGhost(int oldRow, int oldCol, int newRow, int newCol) {
    ghostExist[oldRow][oldCol] = false;
    ghostExist[newRow][newCol] = true;
}


void MoveRandDir(int *ghostrow, int *ghostcol) {
    int oldRow = *ghostrow;
    int oldCol = *ghostcol;
    int randomNumber = getRandomNumber() % 4;
    int attempts = 0; // Track how many times we attempt to find a valid move

    while (attempts < 10) { // Limit number of attempts to prevent infinite loop
        if (randomNumber == 0 && *ghostrow > 0 && !wallExists[*ghostrow - 1][*ghostcol] && !ghostExist[*ghostrow - 1][*ghostcol]) {
            (*ghostrow) -= 1; // move up
            break;
        } else if (randomNumber == 1 && *ghostrow < ROWS - 1 && !wallExists[*ghostrow + 1][*ghostcol] && !ghostExist[*ghostrow + 1][*ghostcol]) {
            (*ghostrow) += 1; // move down
            break;
        } else if (randomNumber == 2 && *ghostcol > 0 && !wallExists[*ghostrow][*ghostcol - 1] && !ghostExist[*ghostrow][*ghostcol - 1]) {
            (*ghostcol) -= 1; // move left
            break;
        } else if (randomNumber == 3 && *ghostcol < COLS - 1 && !wallExists[*ghostrow][*ghostcol + 1] && !ghostExist[*ghostrow][*ghostcol + 1]) {
            (*ghostcol) += 1; // move right
            break;
        } else {
            randomNumber = getRandomNumber() % 4; // Try another direction
        }

        attempts++; // Increment attempts counter
    }

    // Update ghost positions in ghostExist array, if the ghost moved
    if (attempts < 10) {
        ghostExist[oldRow][oldCol] = false;  // Clear old position
        ghostExist[*ghostrow][*ghostcol] = true;  // Set new position
    }
}





bool lineOfSight(int currentRow, int currentCol, char *moving) {
    int i = currentRow, j = currentCol;

    // Look down
    while (i >= 0 && i < ROWS && j >= 0 && j < COLS && !wallExists[i][j]){
        if (playerExist[i][j]) { *moving = 's'; return true; }
        i++;
    }

    i = currentRow; //reset I
    // Look up
    while (i >= 0 && i < ROWS && j >= 0 && j < COLS && !wallExists[i][j]){
        if (playerExist[i][j]) { *moving = 'w'; return true; }
        i--;
    }

    i = currentRow; // reset I
    // Look right
    while (i >= 0 && i < ROWS && j >= 0 && j < COLS && !wallExists[i][j]){
        if (playerExist[i][j]) { *moving = 'd'; return true; }
        j++;
    }

    j = currentCol; //reset J
    // Look left
    while (i >= 0 && i < ROWS && j >= 0 && j < COLS && !wallExists[i][j]){
        if (playerExist[i][j]) { *moving = 'a'; return true; }
        j--;
    }

    return false;
}

void updateChance(int chanceArray[4][4], int numberToChange, int colNum) {
    for (int i = 0; i < 4; i++) {
        if (chanceArray[i][colNum] == numberToChange) {
            chanceArray[i][colNum] += 25;
        } else {
            chanceArray[i][colNum] = 0;
        }
    }
}

void ghostAI(int ghostrow[], int ghostcol[]) {
    int currentRow, currentCol, precent;
    int movementChance[4][4] = {{0, 0, 0, 0}, // Up
                                {0, 0, 0, 0}, // Down
                                {0, 0, 0, 0}, // Left
                                {0, 0, 0, 0}}; // Right
    char moving = 'a'; // Direction ghost has been moving

    for (int i = 0; i < 4; i++) { // Play for all 4 ghosts
        precent = getRandomNumber();
        currentRow = ghostrow[i];
        currentCol = ghostcol[i];

        // Check line of sight and move toward player if possible
        if (lineOfSight(currentRow, currentCol, &moving)) { // If line of sight, move toward player
            switch (moving) {
                case 'a': // Left
                    if (currentCol > 0 && !wallExists[currentRow][currentCol - 1]) {
                        updateGhost(currentRow, currentCol, currentRow, currentCol - 1);
                        ghostcol[i] -= 1;
                    }
                    break;
                case 'w': // Up
                    if (currentRow > 0 && !wallExists[currentRow - 1][currentCol]) {
                        updateGhost(currentRow, currentCol, currentRow - 1, currentCol);
                        ghostrow[i] -= 1;
                    }
                    break;
                case 's': // Down
                    if (currentRow < ROWS - 1 && !wallExists[currentRow + 1][currentCol]) {
                        updateGhost(currentRow, currentCol, currentRow + 1, currentCol);
                        ghostrow[i] += 1;
                    }
                    break;
                case 'd': // Right
                    if (currentCol < COLS - 1 && !wallExists[currentRow][currentCol + 1]) {
                        updateGhost(currentRow, currentCol, currentRow, currentCol + 1);
                        ghostcol[i] += 1;
                    }
                    break;
                default:
                    return;
            }
        } else { // If no line of sight, move randomly
            srand(time(NULL)); // Seed the random generator
            precent = getRandomNumber();

            // Move up
            if (precent + movementChance[0][i] > 75 && currentRow > 0 && !wallExists[currentRow - 1][currentCol]) {
                updateGhost(currentRow, currentCol, currentRow - 1, currentCol);
                updateChance(movementChance, movementChance[0][i], i);
                ghostrow[i] -= 1;
            }
            // Move down
            else if (precent + movementChance[1][i] > 75 && currentRow < ROWS - 1 && !wallExists[currentRow + 1][currentCol]) {
                updateGhost(currentRow, currentCol, currentRow + 1, currentCol);
                updateChance(movementChance, movementChance[1][i], i);
                ghostrow[i] += 1;
            }
            // Move left
            else if (precent + movementChance[2][i] > 75 && currentCol > 0 && !wallExists[currentRow][currentCol - 1]) {
                updateGhost(currentRow, currentCol, currentRow, currentCol - 1);
                updateChance(movementChance, movementChance[2][i], i);
                ghostcol[i] -= 1;
            }
            // Move right
            else if (precent + movementChance[3][i] > 75 && currentCol < COLS - 1 && !wallExists[currentRow][currentCol + 1]) {
                updateGhost(currentRow, currentCol, currentRow, currentCol + 1);
                updateChance(movementChance, movementChance[3][i], i);
                ghostcol[i] += 1;
            } else {
                // Fallback to random direction if no valid move found
                MoveRandDir(&ghostrow[i], &ghostcol[i]);
            }
        }
    }
}



// for the first couple turns, move the ghosts out individually.
void Parentfunct_moveGhosts(int ghostRow[], int ghostCol[], int runTime){
if(runTime < 5){
    MoveRandDir(&ghostRow[0], &ghostCol[0]);
}else if(runTime < 10 && runTime > 5){
    MoveRandDir(&ghostRow[0], &ghostCol[0]);
    MoveRandDir(&ghostRow[1], &ghostCol[1]); //move first 2
}else if(runTime > 10 && runTime < 15){
    MoveRandDir(&ghostRow[0], &ghostCol[0]);
    MoveRandDir(&ghostRow[1], &ghostCol[1]);
    MoveRandDir(&ghostRow[2], &ghostCol[2]); //move first 3
}else{
    ghostAI(ghostRow, ghostCol); //AI takes over
}     
}




void pelletCheck(int r, int c){
    if (pelletsExists[r][c] && playerExist[r][c]) {
        pelletsExists[r][c] = false; // Player picked up pellet
    }
}

void move(int userCord[], char moveInput){
    int cr = userCord[0];
    int cc = userCord[1];
    int nr = cr, nc = cc;

    switch(moveInput){
        case 'a': nc -= 1; break;
        case 'w': nr -= 1; break;
        case 's': nr += 1; break;
        case 'd': nc += 1; break;
        default: return; // Invalid input
    }

    // Check bounds and wall
    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !wallExists[nr][nc]) {
        playerExist[cr][cc] = false; // Clear old position
        playerExist[nr][nc] = true;  // Set new position
        userCord[0] = nr;
        userCord[1] = nc;
        pelletCheck(nr, nc);
    }// player will not move
}

// Print the game map this will do all chars. this will always print the map
//you do not need to do == true
void display_map(){
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++){
            if(wallExists[i][j]){
                wprintf(L"%lc", block);
            }else if(pelletsExists[i][j]){
                wprintf(L"%lc", pellet);}
            else if(playerExist[i][j]){
                wprintf(L"%lc", characterRight);
            }else if(powerPelletExist[i][j]){
                wprintf(L"%lc", powerPellet);
            }else if(ghostExist[i][j]){
                wprintf(L"%lc", ghost);
            }else{
                wprintf(L"%lc", es);
            }
        }
        wprintf(L"\n");
    }
}

void ghostDebug(){ //DELETE BEFORE SUMBITING FINAL
    for (int i = 0; i < ROWS;i++){
        for (int j = 0; j < COLS;j++){
            if(ghostExist[i][j]){
                printf("ghost at %d, %d\n", i,j);
            }
        }
    }
}
int main() {
#ifdef __APPLE__
    setlocale(LC_ALL, "en_US.UTF-8");
#endif
    init_console(); // Set up Unicode output
    int ghostRow[4] = {8,9,9,9};
    int ghostCol[4] = {9,9,8,10};
    int userCord[2] = {15, 9}; // Player start pos
    bool running = true;
    int gameRunTime = 0;


    while (running){
        gameRunTime++;
        char input;
        if (input == '0'){
            running = false;}
        display_map();
        wprintf(L"Enter move (w/a/s/d) or '0' to quit: \n");
        ghostDebug();
        scanf("%c", &input);
        move(userCord, input);
        Parentfunct_moveGhosts(ghostRow, ghostCol, gameRunTime);
}
return 0;
}
